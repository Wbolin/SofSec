MODULE trafficLight(signal, car_in_box)
VAR
	--state : {green, yellow, red};
	red : boolean;
	yellow : boolean;
	green : boolean;


ASSIGN
	init(red) := TRUE;
	next(red) := case
		red & yellow : FALSE;
		signal & red : TRUE;
		yellow : TRUE;
		TRUE : red;
	esac;

	init(yellow) := FALSE;
	next(yellow) := case
		red & yellow : FALSE;
		signal & red & !car_in_box: TRUE;
		yellow : FALSE;
		!signal & green : TRUE;
		TRUE : yellow;
	esac;

	init(green) := FALSE;
	next(green) := case
		red & yellow : TRUE;
		!signal & green : FALSE;
		TRUE : green;
	esac;

DEFINE
	--red_and_yellow := red & yellow;

-- If light is yellow and not red, it should become red
LTLSPEC
	G(yellow & !red -> X(red))

-- If light is yellow and red, it should become green
LTLSPEC
	G(yellow & red -> X(green))

MODULE sensor(light)
VAR
	--on : boolean;
	queue : 0..max_queue;
	--queueCheck : 0..max_queue;

ASSIGN
	init (queue) := 0;
	next (queue) := case
		queue = 0 : {1, 0};
		(light.green | (!light.red & light.yellow)) & queue > 0 & queue < max_queue : {queue - 1, queue, queue + 1};
		(light.green | (!light.red & light.yellow)) & queue > 0 : {queue - 1, queue};
		light.red & queue < max_queue : {queue + 1, queue};
		TRUE : queue;
	esac;

	--init (queueCheck) := 0;
	--next (queueCheck) := queue;

	--init (on) := queue > 0;
	--next (on) := queue > 0;


DEFINE
	max_queue := 5;

MODULE main
VAR
	signal : array 1..3 of boolean;
	--sensor : array 1..3 of 0..5;
	timer : 0..max_green_time;
	car_in_box : boolean;

	light1 : trafficLight(signal[1], car_in_box);
	sensor1 : sensor(light1);

	light2 : trafficLight(signal[2], car_in_box);
	sensor2 : sensor(light2);

	light3 : trafficLight(signal[3], car_in_box);
	sensor3 : sensor(light3);

ASSIGN

	init (car_in_box) := FALSE;
	next (car_in_box) := case
		(light1.green | (!light1.red & light1.yellow)) & sensor1.queue > 0 : TRUE;
		(light2.green | (!light2.red & light2.yellow)) & sensor2.queue > 0 : TRUE;
		(light3.green | (!light3.red & light3.yellow)) & sensor3.queue > 0 : TRUE;
		TRUE : FALSE;
	esac;

	init (timer) := max_green_time;
	next (timer) := case
		(light1.green | light2.green | light3.green) & timer > 0 : timer - 1;
		!light1.green & !light2.green & !light3.green : max_green_time;
		TRUE : timer;
	esac;

	init (signal[1]) := TRUE;
	next (signal[1]) := case
		light1.green & next(timer) = 0 & (sensor2.queue > 0 | sensor3.queue > 0): FALSE;
		!light3.red & light3.yellow & light1.red & sensor1.queue > 0 : TRUE;
		!light2.red & light2.yellow & light1.red & !(sensor3.queue > 0) & sensor1.queue > 0: TRUE;
		TRUE: signal[1];
	esac;


	init (signal[2]) := FALSE;
	next (signal[2]) := case	
		light2.green & next(timer) = 0 & (sensor1.queue > 0| sensor3.queue > 0) : FALSE;
		!light1.red & light1.yellow & light2.red & sensor2.queue > 0 : TRUE;
		!light3.red & light3.yellow & light2.red & !(sensor1.queue > 0) & sensor2.queue > 0: TRUE;
		TRUE : signal[2];
	esac;

	init (signal[3]) := FALSE;
	next (signal[3]) := case
		light3.green & next(timer) = 0 & (sensor1.queue > 0 | sensor2.queue > 0) : FALSE;
		!light2.red & light2.yellow & light3.red & sensor3.queue > 0 : TRUE;
		!light1.red & light1.yellow & light3.red & !(sensor2.queue > 0) & sensor3.queue > 0 : TRUE;
		TRUE : signal[3];
	esac;

DEFINE
	max_green_time := 3;
	not_all_red := count(!light1.red, !light2.red, !light3.red)>0;
	all_red := count(light1.red, light2.red, light3.red) = 3;
	num_of_not_red := count(!light1.red, !light2.red, !light3.red);
	others_waiting := (light1.green & (sensor2.queue > 0 | sensor3.queue > 0)) | (light2.green & (sensor1.queue > 0 | sensor3.queue > 0)) | (light3.green & (sensor1.queue > 0 | sensor2.queue > 0));
	one_green := count(light1.green, light2.green, light3.green) = 1;

FAIRNESS
	others_waiting;



--LTLSPEC
	--G(!light1.green & !light2.green);

--LTLSPEC
	--G(!light1.yellow & !light2.yellow);

LTLSPEC
	G(light1.green | light1.yellow -> light2.red )
LTLSPEC
	G(light2.green | light2.yellow -> light1.red)



LTLSPEC
	G(!(light1.green & light1.red) & !(light1.green & light1.yellow));

LTLSPEC
	G(light1.red & !light1.yellow -> X(light1.red & light1.yellow) | X(light1.red));

LTLSPEC
	G(light1.red & light1.yellow -> X(light1.green));

CTLSPEC
	AG(light1.green -> EF (light1.yellow));

LTLSPEC
	G(light1.green & !signal[1] -> X(light1.yellow));

LTLSPEC
	G(light1.yellow & !light1.red -> X(light1.red & !light1.yellow));

--LTLSPEC
	--G!(light1.green | light2.green)

-- At most one traffic light is not red
LTLSPEC
	G(num_of_not_red<=1)

-- Eventually, waiting drivers will get a green light
LTLSPEC
	G(sensor1.queue > 0 & light1.red -> F(light1.green))

LTLSPEC
	G(sensor2.queue > 0 & light2.red -> F(light2.green))

LTLSPEC
	G(sensor3.queue > 0 & light3.red -> F(light3.green))

--LTLSPEC
	--!G !(sensor1.queue > 0 & light1.red)

--LTLSPEC
	--G !(sensor3.queue > sensor3.queueCheck + 1)

-- Between green lights, all light have to be red for at least one turn
LTLSPEC
	G ((light1.yellow & !light1.red) | (light2.yellow & !light2.red) | (light3.yellow & !light3.red) -> X(light1.red & light2.red & light3.red))

-- lol (same v)
LTLSPEC
	G (not_all_red & num_of_not_red = 1 -> X(all_red) | X(num_of_not_red = 1))

-- Every time a light goes back to red, there is a turn where all lights are red
LTLSPEC
	G(not_all_red -> X(all_red) | X(not_all_red))

-- If timer is 0 and people were already waiting at the other lights, the current green light swithces to red in 2 turns.
LTLSPEC
	G((timer = 0 & Y(others_waiting)) -> X(X(all_red)))

--
LTLSPEC
	G(!others_waiting & one_green -> X(one_green))

-- If green, then eventually it will either become red or the timer will be 0 (until others are waiting)
LTLSPEC
	G (light1.green -> F(timer = 0 U others_waiting) | F(light1.red))

--CTLSPEC
--	AG (light1.green -> EF (light1.red) & EF AG(timer = 0))





